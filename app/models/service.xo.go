// Package models contains the types for schema 'ccdb_dupl'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"database/sql"
	"errors"

	"github.com/go-sql-driver/mysql"
)

// Service represents a row from 'ccdb_dupl.service'.
type Service struct {
	ID                                   uint                `json:"_id"`                                        // _id
	ClientID                             uint                `json:"client_id"`                                  // client_id
	SubscriptionID                       uint                `json:"subscription_id"`                            // subscription_id
	TransactionDate                      mysql.NullTime      `json:"transaction_date"`                           // transaction_date
	NatureOfTransaction                  NatureOfTransaction `json:"nature_of_transaction"`                      // nature_of_transaction
	NatureOfService                      sql.NullString      `json:"nature_of_service"`                          // nature_of_service
	CashReceivedForPaymentToThirdParties sql.NullFloat64     `json:"cash_received_for_payment_to_third_parties"` // cash_received_for_payment_to_third_parties
	TypeOfThirdParties                   sql.NullString      `json:"type_of_third_parties"`                      // type_of_third_parties
	NameOfThirdParty                     sql.NullString      `json:"name_of_third_party"`                        // name_of_third_party

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Service exists in the database.
func (s *Service) Exists() bool {
	return s._exists
}

// Deleted provides information if the Service has been deleted from the database.
func (s *Service) Deleted() bool {
	return s._deleted
}

// Insert inserts the Service to the database.
func (s *Service) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if s._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO ccdb_dupl.service (` +
		`client_id, subscription_id, transaction_date, nature_of_transaction, nature_of_service, cash_received_for_payment_to_third_parties, type_of_third_parties, name_of_third_party` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, s.ClientID, s.SubscriptionID, s.TransactionDate, s.NatureOfTransaction, s.NatureOfService, s.CashReceivedForPaymentToThirdParties, s.TypeOfThirdParties, s.NameOfThirdParty)
	res, err := db.Exec(sqlstr, s.ClientID, s.SubscriptionID, s.TransactionDate, s.NatureOfTransaction, s.NatureOfService, s.CashReceivedForPaymentToThirdParties, s.TypeOfThirdParties, s.NameOfThirdParty)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	s.ID = uint(id)
	s._exists = true

	return nil
}

// Update updates the Service in the database.
func (s *Service) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !s._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if s._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE ccdb_dupl.service SET ` +
		`client_id = ?, subscription_id = ?, transaction_date = ?, nature_of_transaction = ?, nature_of_service = ?, cash_received_for_payment_to_third_parties = ?, type_of_third_parties = ?, name_of_third_party = ?` +
		` WHERE _id = ?`

	// run query
	XOLog(sqlstr, s.ClientID, s.SubscriptionID, s.TransactionDate, s.NatureOfTransaction, s.NatureOfService, s.CashReceivedForPaymentToThirdParties, s.TypeOfThirdParties, s.NameOfThirdParty, s.ID)
	_, err = db.Exec(sqlstr, s.ClientID, s.SubscriptionID, s.TransactionDate, s.NatureOfTransaction, s.NatureOfService, s.CashReceivedForPaymentToThirdParties, s.TypeOfThirdParties, s.NameOfThirdParty, s.ID)
	return err
}

// Save saves the Service to the database.
func (s *Service) Save(db XODB) error {
	if s.Exists() {
		return s.Update(db)
	}

	return s.Insert(db)
}

// Delete deletes the Service from the database.
func (s *Service) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !s._exists {
		return nil
	}

	// if deleted, bail
	if s._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM ccdb_dupl.service WHERE _id = ?`

	// run query
	XOLog(sqlstr, s.ID)
	_, err = db.Exec(sqlstr, s.ID)
	if err != nil {
		return err
	}

	// set deleted
	s._deleted = true

	return nil
}

// Client returns the Client associated with the Service's ClientID (client_id).
//
// Generated from foreign key 'service_ibfk_1'.
func (s *Service) Client(db XODB) (*Client, error) {
	return ClientByID(db, s.ClientID)
}

// Subscription returns the Subscription associated with the Service's SubscriptionID (subscription_id).
//
// Generated from foreign key 'service_ibfk_2'.
func (s *Service) Subscription(db XODB) (*Subscription, error) {
	return SubscriptionByID(db, s.SubscriptionID)
}

// ServicesByClientID retrieves a row from 'ccdb_dupl.service' as a Service.
//
// Generated from index 'client_id'.
func ServicesByClientID(db XODB, clientID uint) ([]*Service, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`_id, client_id, subscription_id, transaction_date, nature_of_transaction, nature_of_service, cash_received_for_payment_to_third_parties, type_of_third_parties, name_of_third_party ` +
		`FROM ccdb_dupl.service ` +
		`WHERE client_id = ?`

	// run query
	XOLog(sqlstr, clientID)
	q, err := db.Query(sqlstr, clientID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Service{}
	for q.Next() {
		s := Service{
			_exists: true,
		}

		// scan
		err = q.Scan(&s.ID, &s.ClientID, &s.SubscriptionID, &s.TransactionDate, &s.NatureOfTransaction, &s.NatureOfService, &s.CashReceivedForPaymentToThirdParties, &s.TypeOfThirdParties, &s.NameOfThirdParty)
		if err != nil {
			return nil, err
		}

		res = append(res, &s)
	}

	return res, nil
}

// ServiceByID retrieves a row from 'ccdb_dupl.service' as a Service.
//
// Generated from index 'service__id_pkey'.
func ServiceByID(db XODB, id uint) (*Service, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`_id, client_id, subscription_id, transaction_date, nature_of_transaction, nature_of_service, cash_received_for_payment_to_third_parties, type_of_third_parties, name_of_third_party ` +
		`FROM ccdb_dupl.service ` +
		`WHERE _id = ?`

	// run query
	XOLog(sqlstr, id)
	s := Service{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&s.ID, &s.ClientID, &s.SubscriptionID, &s.TransactionDate, &s.NatureOfTransaction, &s.NatureOfService, &s.CashReceivedForPaymentToThirdParties, &s.TypeOfThirdParties, &s.NameOfThirdParty)
	if err != nil {
		return nil, err
	}

	return &s, nil
}

// ServicesBySubscriptionID retrieves a row from 'ccdb_dupl.service' as a Service.
//
// Generated from index 'subscription_id'.
func ServicesBySubscriptionID(db XODB, subscriptionID uint) ([]*Service, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`_id, client_id, subscription_id, transaction_date, nature_of_transaction, nature_of_service, cash_received_for_payment_to_third_parties, type_of_third_parties, name_of_third_party ` +
		`FROM ccdb_dupl.service ` +
		`WHERE subscription_id = ?`

	// run query
	XOLog(sqlstr, subscriptionID)
	q, err := db.Query(sqlstr, subscriptionID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Service{}
	for q.Next() {
		s := Service{
			_exists: true,
		}

		// scan
		err = q.Scan(&s.ID, &s.ClientID, &s.SubscriptionID, &s.TransactionDate, &s.NatureOfTransaction, &s.NatureOfService, &s.CashReceivedForPaymentToThirdParties, &s.TypeOfThirdParties, &s.NameOfThirdParty)
		if err != nil {
			return nil, err
		}

		res = append(res, &s)
	}

	return res, nil
}
